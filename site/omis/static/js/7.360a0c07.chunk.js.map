{"version":3,"sources":["../static/js/7.360a0c07.chunk.js","docs/zh-cn/global-store.md"],"names":["webpackJsonp","51","module","exports"],"mappings":"AAAAA,cAAc,IAERC,GACA,SAAUC,EAAQC,GCHxBD,EAAAC,QAAA","file":"static/js/7.360a0c07.chunk.js","sourcesContent":["webpackJsonp([7],{\n\n/***/ 51:\n/***/ (function(module, exports) {\n\nmodule.exports = \"## GlobalStore 是什么？\\n\\nGlobalStore 是 Omis 内置的中心化数据仓库，他解决和提供了下面问题和能力：\\n\\n* 组件树数据共享\\n* 数据变更按需更新依赖的组件\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/store.cn.jpg)\\n\\n## 一段代码完全上手 GlobalStore\\n\\n```jsx\\nimport { render, h } from 'omi'\\n\\nconst Counter = function (props, store, _, $) {\\n  return <p>\\n    Clicked: {$.data.count} times\\n    {' '}\\n    <button onClick={store.add}>+</button>\\n    <button onClick={store.sub}>-</button>\\n    <button onClick={store.addIfOdd}>\\n      Add if odd\\n      </button>\\n    <button onClick={store.addAsync}>\\n      Add async\\n      </button>\\n  </p>\\n}\\n\\nCounter.use = ['count']\\n\\nCounter.store = (_, $) => {\\n  return {\\n    add() {\\n      $.add()\\n    },\\n    sub() {\\n      $.sub()\\n    },\\n    addIfOdd() {\\n      if ($.data.count % 2 !== 0) {\\n        $.add()\\n      }\\n    },\\n    addAsync() {\\n      setTimeout(() => $.add(), 1000)\\n    }\\n  }\\n}\\n\\nrender(<Counter />, 'body', {\\n  data: {\\n    count: 0\\n  },\\n  sub() {\\n    this.data.count--\\n  },\\n  add() {\\n    this.data.count++\\n  }\\n})\\n```\\n\\n* 通过 `use` 声明依赖的 path\\n* `globalStore` 通过 render 的第三个参数从根节点注入到所有组件，通过`$`访问。\\n\\n下面举一个复杂的 `use` 例子。\\n\\nStore 里的 data:\\n\\n```json\\n{\\n  count: 0,\\n  arr: ['china', 'tencent'],\\n  motto: 'I love omi.',\\n  userInfo: {\\n    firstName: 'dnt',\\n    lastName: 'zhang',\\n    age: 18\\n  }\\n}\\n```\\n\\nStatic use:\\n\\n```jsx\\nComp.use = [\\n  'count', //直接字符串，可通过 this.using[0] 访问\\n  'arr[0]', //也支持 path，可通过 this.using[1] 访问\\n  //支持 json\\n  {\\n    //alias，可通过 this.using.reverseMotto 访问\\n    reverseMotto: [\\n      'motto', //path\\n      target => target.split('').reverse().join('')  //computed\\n    ]\\n  },\\n  { name: 'arr[1]' }, //{ alias: path }，可通过 this.using.name 访问\\n  {\\n    //alias，可通过 this.using.fullName 访问\\n    fullName: [\\n      ['userInfo.firstName', 'userInfo.lastName'], //path array\\n      (firstName, lastName) => firstName + lastName //computed\\n    ]\\n  },\\n]\\n```\\n\\n下面看看 JSX 中使用:\\n\\n```jsx\\n...\\n...\\n<div>\\n  <button onClick={this.sub}>-</button>\\n  <span>{this.using[0]}</span>\\n  <button onClick={this.add}>+</button>\\n  <div>\\n    <span>{this.using[1]}</span>\\n    <button onClick={this.rename}>rename</button>\\n  </div>\\n  <div>{this.using.reverseMotto}</div><button onClick={this.changeMotto}>change motto</button>\\n  <div>{this.using.name}</div>\\n  <div>{this.using[3]}</div>\\n  <div>\\n    {this.using.fullName}\\n    <button onClick={this.changeFirstName}>change first name</button>\\n  </div>\\n</div>\\n...\\n...\\n```\\n\\n如果不带有 alias ，你也可以直接通过 `$.data.xxx` 访问。\\n\\n\\n当 `$.data` 发生变化，依赖变更数据的组件会进行更新，举例说明 Path 命中规则:\\n\\n| Proxy Path(由数据更改产生) | static use 中的 path | 是否更新 |\\n| ---------- | ---------- | -------- |\\n| abc        | abc        | 更新     |\\n| abc[1]     | abc        | 更新     |\\n| abc.a      | abc        | 更新     |\\n| abc        | abc.a      | 不更新   |\\n| abc        | abc[1]     | 不更新   |\\n| abc        | abc[1].c   | 不更新   |\\n| abc.b      | abc.b      | 更新     |\\n\\n以上只要命中一个条件就可以进行更新！\\n\\n总结： 只要注入组件的 path 等于 use 里声明 或者在 use 里声明的其中 path 子节点下就会进行更新！\\n\\n### 解构赋值\\n\\n```jsx\\nconst Comp = function() {\\n  const [menus, sideBarShow, lan] = this.using\\n\\n  return (\\n    <div class={`list${sideBarShow ? ' show' : ''}`}>\\n      {menus[lan].map((menu, index) => (\\n        <my-list menu={menu} index={index} />\\n      ))}\\n    </div>\\n  )\\n}\\n\\nComp.use = [\\n  'menus',\\n  'sideBarShow',\\n  'lan'\\n]\\n```\\n\\n这里举了个例子使用 ES2015+ 语法  `const [xx, xxx] = xxxx` 的语法快速赋值。\\n\\n## 动态 use\\n\\n如果你不希望同样的组件拥有同样的依赖，可以使用动态的 use：\\n\\n\\n```js\\nComp.store = _ => {\\n  _.use = [\\n    'a.b',\\n    'c[1].d',\\n    `e.f.${xxx}.d[${index}]`\\n  ]\\n}\\n```\\n\\n非常灵活！\\n\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/7.360a0c07.chunk.js","module.exports = \"## GlobalStore 是什么？\\n\\nGlobalStore 是 Omis 内置的中心化数据仓库，他解决和提供了下面问题和能力：\\n\\n* 组件树数据共享\\n* 数据变更按需更新依赖的组件\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/store.cn.jpg)\\n\\n## 一段代码完全上手 GlobalStore\\n\\n```jsx\\nimport { render, h } from 'omi'\\n\\nconst Counter = function (props, store, _, $) {\\n  return <p>\\n    Clicked: {$.data.count} times\\n    {' '}\\n    <button onClick={store.add}>+</button>\\n    <button onClick={store.sub}>-</button>\\n    <button onClick={store.addIfOdd}>\\n      Add if odd\\n      </button>\\n    <button onClick={store.addAsync}>\\n      Add async\\n      </button>\\n  </p>\\n}\\n\\nCounter.use = ['count']\\n\\nCounter.store = (_, $) => {\\n  return {\\n    add() {\\n      $.add()\\n    },\\n    sub() {\\n      $.sub()\\n    },\\n    addIfOdd() {\\n      if ($.data.count % 2 !== 0) {\\n        $.add()\\n      }\\n    },\\n    addAsync() {\\n      setTimeout(() => $.add(), 1000)\\n    }\\n  }\\n}\\n\\nrender(<Counter />, 'body', {\\n  data: {\\n    count: 0\\n  },\\n  sub() {\\n    this.data.count--\\n  },\\n  add() {\\n    this.data.count++\\n  }\\n})\\n```\\n\\n* 通过 `use` 声明依赖的 path\\n* `globalStore` 通过 render 的第三个参数从根节点注入到所有组件，通过`$`访问。\\n\\n下面举一个复杂的 `use` 例子。\\n\\nStore 里的 data:\\n\\n```json\\n{\\n  count: 0,\\n  arr: ['china', 'tencent'],\\n  motto: 'I love omi.',\\n  userInfo: {\\n    firstName: 'dnt',\\n    lastName: 'zhang',\\n    age: 18\\n  }\\n}\\n```\\n\\nStatic use:\\n\\n```jsx\\nComp.use = [\\n  'count', //直接字符串，可通过 this.using[0] 访问\\n  'arr[0]', //也支持 path，可通过 this.using[1] 访问\\n  //支持 json\\n  {\\n    //alias，可通过 this.using.reverseMotto 访问\\n    reverseMotto: [\\n      'motto', //path\\n      target => target.split('').reverse().join('')  //computed\\n    ]\\n  },\\n  { name: 'arr[1]' }, //{ alias: path }，可通过 this.using.name 访问\\n  {\\n    //alias，可通过 this.using.fullName 访问\\n    fullName: [\\n      ['userInfo.firstName', 'userInfo.lastName'], //path array\\n      (firstName, lastName) => firstName + lastName //computed\\n    ]\\n  },\\n]\\n```\\n\\n下面看看 JSX 中使用:\\n\\n```jsx\\n...\\n...\\n<div>\\n  <button onClick={this.sub}>-</button>\\n  <span>{this.using[0]}</span>\\n  <button onClick={this.add}>+</button>\\n  <div>\\n    <span>{this.using[1]}</span>\\n    <button onClick={this.rename}>rename</button>\\n  </div>\\n  <div>{this.using.reverseMotto}</div><button onClick={this.changeMotto}>change motto</button>\\n  <div>{this.using.name}</div>\\n  <div>{this.using[3]}</div>\\n  <div>\\n    {this.using.fullName}\\n    <button onClick={this.changeFirstName}>change first name</button>\\n  </div>\\n</div>\\n...\\n...\\n```\\n\\n如果不带有 alias ，你也可以直接通过 `$.data.xxx` 访问。\\n\\n\\n当 `$.data` 发生变化，依赖变更数据的组件会进行更新，举例说明 Path 命中规则:\\n\\n| Proxy Path(由数据更改产生) | static use 中的 path | 是否更新 |\\n| ---------- | ---------- | -------- |\\n| abc        | abc        | 更新     |\\n| abc[1]     | abc        | 更新     |\\n| abc.a      | abc        | 更新     |\\n| abc        | abc.a      | 不更新   |\\n| abc        | abc[1]     | 不更新   |\\n| abc        | abc[1].c   | 不更新   |\\n| abc.b      | abc.b      | 更新     |\\n\\n以上只要命中一个条件就可以进行更新！\\n\\n总结： 只要注入组件的 path 等于 use 里声明 或者在 use 里声明的其中 path 子节点下就会进行更新！\\n\\n### 解构赋值\\n\\n```jsx\\nconst Comp = function() {\\n  const [menus, sideBarShow, lan] = this.using\\n\\n  return (\\n    <div class={`list${sideBarShow ? ' show' : ''}`}>\\n      {menus[lan].map((menu, index) => (\\n        <my-list menu={menu} index={index} />\\n      ))}\\n    </div>\\n  )\\n}\\n\\nComp.use = [\\n  'menus',\\n  'sideBarShow',\\n  'lan'\\n]\\n```\\n\\n这里举了个例子使用 ES2015+ 语法  `const [xx, xxx] = xxxx` 的语法快速赋值。\\n\\n## 动态 use\\n\\n如果你不希望同样的组件拥有同样的依赖，可以使用动态的 use：\\n\\n\\n```js\\nComp.store = _ => {\\n  _.use = [\\n    'a.b',\\n    'c[1].d',\\n    `e.f.${xxx}.d[${index}]`\\n  ]\\n}\\n```\\n\\n非常灵活！\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/zh-cn/global-store.md\n// module id = 51\n// module chunks = 7"],"sourceRoot":""}